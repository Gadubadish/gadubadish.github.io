<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>TEST</title>
<style>
    :root {
    --img-w: 40vw;
    --img-x: 10vw;
    --img-y: 15vh;
}
html { zoom: 1; }
body {
    margin: 0;
    overflow: hidden;
    background: black url(images/background.jpeg) no-repeat;
    
    background-size:  150%;
    background-position: -5vw -35vh;
}
canvas { display: block; }



</style>
</head>
<body>

  <div id="debug" style="position:fixed; top:10px; left:10px; 
      width:1000px; max-height:90vh; overflow-y:auto; 
      color:#f00; font-family:monospace; 
      font-size:25px; padding:5px;pointer-events: none; z-index:1000;">
      </div id="UI">

      <img id="crt"src="images/CRT.png"style="position:relative; top: 15vh; width: 80vw; z-index: ;" >
      <img id = "img"; class = "UI"; src="images/CRTknob.png" style="position:absolute;  width: 80vw; z-index: 1;" >
      <img src="images/spectrumanalizer.png" style=" position: absolute; left: 67vw; top: 30vh; width: 20vw" >
      <div id="entityContainer" 
     style="position: absolute; 
            left: 71.65vw; top: 41.5vh; 
            width: 9vw; height: 21vh; 
            overflow: hidden; 
            border: 0px solid #0f0;"> <!-- optional border for debugging -->

    <img id="entityImg" src="tra.png" 
         style="position: absolute; 
                width: 100%; height: 100%; 
                object-fit: cover;">
</div>
</div>

<script type="module">
import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js';

const img = document.getElementById('img');

img.style.transformOrigin = "1590px 323px";

let imageUpdate = false;

// --- Plane & animation flags ---
let plane, hoverPlane;
let startupDone = false;
let SUinitiated = false;

// --- Fixed layout dimensions ---
const size = 1.15;
const WIDTH = 1920*size;
const HEIGHT = 1080*size;
const ASPECT = WIDTH / HEIGHT;

let currentHoverScale = 0; // current extrusion
let targetHoverScale = 0;  // target extrusion for hovered line
const maxHoverScale = 0.05; // maximum extrusion
const hoverLerpSpeed = 0.08; // how fast it interpolates

let renderedLines = []; // { text, sourceIndex }

let scrollOffset = 0;          // tracks which line is at the top
const visibleLines = 21;       // number of lines visible on the terminal canvas


let debugLines = [];
let inputlist = ["help", "help", "help"];
let inputValue = "";
let placehold = "";
let isReturn = false;

let knobRot = 0;

const crtImg = document.getElementById('crt');

const r = crtImg.getBoundingClientRect();




// --- Data ---
const entities = {
"barber": { health: "Invincible", power: 1, max: 1, favoriteMoon: "7-dine", image: "Barber.jpg" },
  "bracken": { health: 5, power: 3, max: 1, favoriteMoon: "56-vow", image: "Bracken.jpg" },
  "bunker spider": { health: 5, power: 2, max: 1, favoriteMoon: "41-experimentation", image: "Bunkerspider.jpg" },
  "butler": { health: "2(SP*)/8(MP*)", power: 2, max: 7, favoriteMoon: "7-dine", image: "Butler.jpg" },
  "coil-head": { health: "Invincible", power: 1, max: 5, favoriteMoon: "21-offense", image: "Coilhead.jpg" },
  "ghost girl": { health: "Invincible", power: 2, max: 1, favoriteMoon: "85-rend", image: "Ghostgirl.jpg" },
  "hoarding bug": { health: 3, power: 1, max: 8, favoriteMoon: "5-embrion", image: "Hoardingbug.png" },
  "hygrodere": { health: "Invincible", power: 1, max: 2, favoriteMoon: "21-offense", image: "Hygrodere.jpg" },
  "jester": { 
    health: "Invincible", power: 3, max: 1, favoriteMoon: "85-rend", image: "Jester.png", 
  },  "maneater": { health: 5, power: 2, max: 1, favoriteMoon: "56-vow", image: "Maneater.jpg" },
  "masked": { health: 4, power: 1, max: 10, favoriteMoon: "68-artifice", image: "Masked.jpg" },
  "nutcracker": { health: 5, power: 1, max: 10, favoriteMoon: "85-rend", image: "Nutcracker.jpg" },
  "snare flea": { health: 3, power: 1, max: 4, favoriteMoon: "220-assurance", image: "Snareflea.jpg" },
  "spore lizard": { health: "Invincible", power: 1, max: 2, favoriteMoon: "5-embrion", image: "Sporelizard.jpg" },
  "thumper": { health: 4, power: 3, max: 4, favoriteMoon: "21-offense", image: "Thumper.jpg" },
  "baboon hawk": { health: 4, power: 0.5, max: 15, favoriteMoon: "20-adamance", image: "Baboonhawk.jpg" },
  "earth leviathan": { health: "Invincible", power: 2, max: 3, favoriteMoon: "220-assurance", image: "Earthleviathan.jpg" },
  "eyeless dog": { health: 12, power: 2, max: 8, favoriteMoon: "8-titan", image: "Eyelessdog.jpg" },
  "forest keeper": { health: 38, power: 3, max: 3, favoriteMoon: "56-vow", image: "Forestgiant.jpg" },
  "old bird": { health: "Invincible", power: 3, max: 20, favoriteMoon: "5-embrion", image: "Oldbird.jpg" }
};

const moons = {
  "71-gordion": { difficulty: "Safe", cost: 0, interiorLayout: "-", mapPhoto: "71-gordion" },
  "41-experimentation": { difficulty: "Easy", cost: 0, interiorLayout: "The Factory (99%)", mapPhoto: "41-experimentation" },
  "220-assurance": { difficulty: "Easy", cost: 0, interiorLayout: "The Factory (87%)", mapPhoto: "220-assurance" },
  "56-vow": { difficulty: "Easy", cost: 0, interiorLayout: "The Factory (54%)", mapPhoto: "56-vow" },
  "21-offense": { difficulty: "Intermediate", cost: 0, interiorLayout: "The Mineshaft (60%)", mapPhoto: "21-offense" },
  "61-march": { difficulty: "Intermediate", cost: 0, interiorLayout: "The Factory (100%)", mapPhoto: "61-march" },
  "20-adamance": { difficulty: "Intermediate", cost: 0, interiorLayout: "The Factory (67%)", mapPhoto: "20-adamance" },
  "85-rend": { difficulty: "Hard", cost: 550, interiorLayout: "The Mansion (85%)", mapPhoto: "85-rend" },
  "7-dine": { difficulty: "Hard", cost: 600, interiorLayout: "The Mansion (67%)", mapPhoto: "7-dine" },
  "8-titan": { difficulty: "Hard", cost: 700, interiorLayout: "The Factory (64%)", mapPhoto: "8-titan" },
  "5-embrion": { difficulty: "-", cost: 0, interiorLayout: "-", mapPhoto: "5-embrion" },
  "68-artifice": { difficulty: "-", cost: 0, interiorLayout: "-", mapPhoto: "68-artifice" }
};


fetch("dataset.json")
  .then(res => res.json())
  .then(data => {
    Object.keys(entities).forEach(key => {
      const formattedKey = key.charAt(0).toUpperCase() + key.slice(1);

      const entityInfo = data.entities?.[formattedKey];

      if (entityInfo) {
        entities[key].info = entityInfo;
      }
    });

    console.log(entities);
  });


// --- Audio ---
const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
let buffer;
fetch("sfx/click.mp3")
  .then(r => r.arrayBuffer())
  .then(data => audioCtx.decodeAudioData(data))
  .then(decoded => buffer = decoded);
function playClick() {
    if (!buffer) return;
    const source = audioCtx.createBufferSource();
    source.buffer = buffer;
    source.playbackRate.value = 0.9 + Math.random() * 0.2;
    source.connect(audioCtx.destination);
    source.start();
}

function debug(text) {
    const debugDiv = document.getElementById("debug");
    const p = document.createElement("div");
    p.textContent = text;
    debugDiv.appendChild(p);

    // Keep last 50 messages
    while (debugDiv.children.length > 50) {
        debugDiv.removeChild(debugDiv.firstChild);
    }

    // Auto scroll to bottom
    debugDiv.scrollTop = debugDiv.scrollHeight;
}





// --- Scene setup ---
const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(60, ASPECT, 0.1, 1000);
camera.position.z = 7;

const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
renderer.setClearColor(0x000000, 0);
renderer.setSize(WIDTH, HEIGHT);
renderer.domElement.style.position = "absolute";

document.body.appendChild(renderer.domElement);

function syncRendererToCRT() {
    const rect = crtImg.getBoundingClientRect();
    const vw = window.innerWidth;
    const vh = window.innerHeight;

    // Compute position & size as percentages of viewport
    const leftPct = (rect.left / vw) * 100;
    const topPct  = (rect.top / vh) * 100;
    const widthPct  = (rect.width / vw) * 110;
    const heightPct = (rect.height / vh) * 110;

    // Set renderer size to match CRT element
    renderer.setSize(rect.width, rect.height, false);
    renderer.setPixelRatio(window.devicePixelRatio);


    // Position renderer using viewport percentage
    renderer.domElement.style.position = 'absolute';
    renderer.domElement.style.left = `${leftPct -10.5}vw`;
    renderer.domElement.style.top  = `${topPct - 7}vh`;
    renderer.domElement.style.width = `${widthPct}vw`;
    renderer.domElement.style.height = `${heightPct}vh`;

    // Update camera aspect
    camera.aspect = rect.width / rect.height;
    camera.updateProjectionMatrix();
}




// --- Terminal canvas ---
const canvas = document.createElement('canvas');
canvas.width = 1024;
canvas.height = canvas.width*.5625;
const ctx = canvas.getContext('2d');
ctx.fillStyle = 'black';
ctx.fillRect(0, 0, canvas.width, canvas.height);
ctx.fillStyle = '#00ff00';
ctx.font = '20px monospace';
const texture = new THREE.CanvasTexture(canvas);

// --- Hover plane canvas ---
const hoverCanvas = document.createElement('canvas');
hoverCanvas.width = canvas.width;
hoverCanvas.height = canvas.height;
const hoverCtx = hoverCanvas.getContext('2d');
const hoverTexture = new THREE.CanvasTexture(hoverCanvas);

// --- CRT-like curved plane geometry ---
const width = 6;
const height = width*.75;
const segmentsX = 60;
const segmentsY = 60;
const geometry = new THREE.PlaneGeometry(width, height, segmentsX, segmentsY);
const positions = geometry.attributes.position.array;
for (let i = 0; i < positions.length; i += 3) {
    const x = positions[i], y = positions[i+1];
    const r = Math.sqrt((x/(width/2))**2 + (y/(height/2))**2);
    positions[i+2] = 0.6 * Math.cos(r * Math.PI/2); 
}
geometry.attributes.position.needsUpdate = true;
geometry.computeVertexNormals();

// --- Main plane ---
const material = new THREE.MeshBasicMaterial({ map: texture, transparent: true });
plane = new THREE.Mesh(geometry, material);
plane.visible = false;
scene.add(plane);

// --- Hover plane (inflated along normals) ---
const hoverGeometry = geometry.clone();
const normals = hoverGeometry.attributes.normal.array;
const hoverPositions = hoverGeometry.attributes.position.array;
const hoverScale = 0.05;
for (let i = 0; i < hoverPositions.length; i += 3) {
    hoverPositions[i]     += normals[i]     * hoverScale;
    hoverPositions[i + 1] += normals[i + 1] * hoverScale;
    hoverPositions[i + 2] += normals[i + 2] * hoverScale;
}
hoverGeometry.attributes.position.needsUpdate = true;
hoverGeometry.computeVertexNormals();

const hoverMaterial = new THREE.MeshBasicMaterial({ map: hoverTexture, transparent: true });
hoverPlane = new THREE.Mesh(hoverGeometry, hoverMaterial);
hoverPlane.visible = false;
scene.add(hoverPlane);


function wrapText(ctx, text, maxWidth) {
    const words = text.split(" ");
    const lines = [];
    let current = "";

    for (let word of words) {
        const test = current ? current + " " + word : word;
        if (ctx.measureText(test).width > maxWidth && current) {
            lines.push(current);
            current = word;
        } else {
            current = test;
        }
    }
    if (current) lines.push(current);
    return lines;
}


// --- Terminal text setup ---
let lines = ["For a list of commands type or click:", "HELP"];
let currentInput = "";
const leftPadding = 10;
const firstLineY = 25;
const lineHeight = 25;
const inputBaselineOffset = 30;

// --- Hover state ---
let hoveredLine = -1;
let lastHovered = -2;



// --- Scanlines ---
function drawScanlines(ctx, canvasWidth, canvasHeight, spacing = 2) {
    ctx.strokeStyle = 'rgba(0,255,0,0.2)';
    ctx.lineWidth = 1;
    for (let y = 0; y < canvasHeight; y += spacing) {
        ctx.beginPath();
        ctx.moveTo(0, y + 0.8);
        ctx.lineTo(canvasWidth, y + 0.5);
        ctx.stroke();
    }
}

// --- Startup animation ---
async function startupAnimation() {
    plane.visible = true;
    ctx.fillStyle = 'transparent';
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    const steps = 96;
    const delay = 10;
    for (let i = 0; i < steps; i++) {
        ctx.fillStyle = `rgba(0,255,0,${i / (4*steps)})`;
        ctx.fillRect(0, 6 * i, canvas.width, 2);
        texture.needsUpdate = true;
        await new Promise(r => setTimeout(r, delay));
    }

    ctx.fillStyle = '#00ff00';
    ctx.shadowColor = 'rgba(0,255,0,1)';
    ctx.shadowBlur = 10;
    ctx.font = '28px monospace';
    ctx.fillText("GORDION INDUSTRIES", canvas.width/2 - 130, canvas.height/2);
    texture.needsUpdate = true;
    await new Promise(r => setTimeout(r, 1000));
    renderCanvas();
}

// --- Hover plane render ---
function renderHoverCanvas() {
    hoverCtx.clearRect(0, 0, hoverCanvas.width, hoverCanvas.height);

    if (hoveredLine === -1) {
        hoverPlane.visible = false;
        return;
    }

    hoverPlane.visible = true;
    hoverCtx.font = '25px monospace';
    hoverCtx.fillStyle = '#00AD20';
    hoverCtx.shadowColor = '#00AD20';
    hoverCtx.shadowBlur = 18;

    let y = firstLineY;
    const startRow = scrollOffset;
    const endRow = Math.min(scrollOffset + visibleLines, renderedLines.length);

    for (let i = startRow; i < endRow; i++) {
        const row = renderedLines[i];
        if (row.sourceIndex === hoveredLine || (hoveredLine === lines.length && row.sourceIndex === lines.length-0)) {
            hoverCtx.fillText(row.text, leftPadding, y);
        }
        y += lineHeight;
    }

    // Input line hover
   

    hoverTexture.needsUpdate = true;
}


// --- Render function ---
function renderCanvas() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    renderedLines = [];

    if (!plane.visible) return;

    ctx.font = '25px monospace';
    ctx.fillStyle = '#00ff00';
    ctx.shadowColor = '#00ff00';
    ctx.shadowBlur = 15;

    const maxTextWidth = canvas.width - leftPadding * 2;

    // Build renderedLines for all lines (with wrapping)
    for (let i = 0; i < lines.length; i++) {
        const wrapped = wrapText(ctx, lines[i], maxTextWidth);
        for (let w = 0; w < wrapped.length; w++) {
            renderedLines.push({ text: wrapped[w], sourceIndex: i });
        }
    }

    // Draw only visible rows
    let y = firstLineY;
    const startRow = scrollOffset;
    const endRow = Math.min(scrollOffset + visibleLines, renderedLines.length);

    for (let i = startRow; i < endRow; i++) {
        const row = renderedLines[i];
        if (row.sourceIndex !== hoveredLine) ctx.fillText(row.text, leftPadding, y);
        y += lineHeight;
    }

    // Draw input line below visible rows
    ctx.shadowBlur = 0;
    ctx.fillText("> " + currentInput + "_", leftPadding, y + inputBaselineOffset - lineHeight);

    drawScanlines(ctx, canvas.width, canvas.height, 6);
    texture.needsUpdate = true;

    renderHoverCanvas();
}





function updateHoverPlane() {
    currentHoverScale += (targetHoverScale - currentHoverScale) * hoverLerpSpeed;

    for (let i = 0; i < hoverPositions.length; i += 3) {
        hoverPositions[i]     = geometry.attributes.position.array[i]     + normals[i]     * currentHoverScale;
        hoverPositions[i + 1] = geometry.attributes.position.array[i + 1] + normals[i + 1] * currentHoverScale;
        hoverPositions[i + 2] = geometry.attributes.position.array[i + 2] + normals[i + 2] * currentHoverScale;
    }
    hoverGeometry.attributes.position.needsUpdate = true;
    hoverGeometry.computeVertexNormals();
}
function executeInput(inputValue) {
    scrollOffset = 0;

      if (imageUpdate = true){
imageUpdate = false;
document.getElementById("entityImg").src = "tra.png";

      }


if (!isReturn) { inputlist = inputlist.concat(inputValue);}



if (isReturn) {
    
isReturn = false;
inputlist.pop();
inputValue = inputlist[inputlist.length - 1];
    

};



    
    
  


    

    lines = []; // clear current terminal lines
    
    

    const commandFn = commands[inputValue.toLowerCase()];
    if (commandFn) {
        const result = commandFn();
        if (result && result.length) result.forEach(line => lines.push(line));
    } else if (inputValue in moons) {
        const m = moons[inputValue];
        lines.push(
  inputValue.toUpperCase(),
  "DIFFICULTY", String(m.difficulty),
  "COST", String(m.cost),
  "INTERIOR LAYOUT", String(m.interiorLayout)
  
);

    } else if (inputValue in entities) {
        const e = entities[inputValue];
       lines.push(
  inputValue.toUpperCase(),
  "HEALTH", String(e.health),
  "POWER", String(e.power),
  "MAX SPAWNS", String(e.max),
  "FAVOURITE MOON", String(e.favoriteMoon),
  "INFO", String(e.info || "")
);

        document.getElementById("entityImg").src = `images/entities/${e.image}`;
        imageUpdate = true;
    } else if (inputValue !== "") {
        lines.push("Unknown command: " + inputValue, "For a list of commands type or click:","HELP");
    } 
    inputValue = "";
    currentInput = "";
    //if (lines.length > 21) lines = lines.slice(lines.length - 21);
    renderCanvas(); 

   





}




// --- Commands ---
const commands = {
    help: () => ["[Tab] to go back", "Available commands:", "HELP", "ABOUT", "CLEAR", "ENTITIES", "MOONS"],
    
    about: () => [`Lethal Company es un juego centrado en la recolección de chatarra. Con una nave autopilotada te diriges a unas lunas llenas de entidades hostiles, y tu objetivo es explorar instalaciones abandonadas que contienen estas. Esto con el objetivo de recolectar la mayor cantidad de chatarra posible y vendérsela a una misteriosa organización, conocida simplemente como "La Compañía", para cumplir con su cuota de tres días. La cuota aumenta cada vez, y siempre tienes tres días en el juego para completarla. Vender chatarra antes te da menos: el 53% de su valor el primer día, el 77% el segundo y el 100% el tercero. Si el jugador falla en completar la cuota, el usuario perderá la partida y empezará una nueva. Cualquier chatarra que vendas por encima de la cuota requerida te recompensa con créditos adicionales.
`,"", `Con el dinero que ganes vendiendo chatarra, puedes comprar equipo para mejorar tus incursiones. Como una linterna, una pala o una mochila. También podrás adquirir mejoras para tu nave, como un teletransportador. Otra opción es comprar combustible extra para viajar a lunas nuevas o incluso conseguir decoraciones para personalizar tu nave.`],
    entities: () => Object.keys(entities).map(name => name.toUpperCase()),
    moons: () => Object.keys(moons).map(name => name.toUpperCase()),

    clear: () => { lines = []; return ["Terminal cleared."]; }
};

// --- Input handling ---
// --- Input handling ---
window.addEventListener('keydown', async (e) => {
    
    
    if (startupDone)playClick();
    
    
    if (!startupDone) {
        if (SUinitiated) return;
        new Audio("sfx/start.mp3").play();
        SUinitiated = true;
        await startupAnimation();
        startupDone = true;
        return;
    }

    if (audioCtx.state === 'suspended') audioCtx.resume();

    if (e.key.length === 1) currentInput += e.key;
    if (e.key === "Backspace") currentInput = currentInput.slice(0, -1);
    if (e.key === "Enter") {
        executeInput(currentInput.trim());
    } if (e.key === "Tab") {
        e.preventDefault();
        isReturn = true;
        executeInput(currentInput.trim());  
    }

    renderCanvas();
});





// --- Raycaster & hover ---
const raycaster = new THREE.Raycaster();
const mouse = new THREE.Vector2();

function onMouseMove(event) {
    
    
    if (!startupDone) return;
    if (hoveredLine >= 0) targetHoverScale = maxHoverScale;
    else currentHoverScale = 0;

    const rect = renderer.domElement.getBoundingClientRect();


    mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
    mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

   

    raycaster.setFromCamera(mouse, camera);
    const intersects = raycaster.intersectObject(plane);
    if (intersects.length > 0 && intersects[0].uv) {
        const uv = intersects[0].uv;
        const canvasY = (1 - uv.y) * canvas.height;
        const row = Math.floor((canvasY - firstLineY) / lineHeight) + scrollOffset;
const index = renderedLines[row]?.sourceIndex ?? -1;


        const inputY = inputBaselineOffset + lines.length * lineHeight; 
        
        let newHovered = -1;
        
        if (index >= 0 && index < lines.length) {
    const lineContent = lines[index];
    const groupNames = {commands: Object.keys(commands)}
    const commandNames = Object.keys(commands).concat(Object.keys(moons)).concat(Object.keys(entities));
    if (commandNames.some(cmd => lineContent.toLowerCase().includes(cmd.toLowerCase()))) {
        newHovered = index;
    } 
    
}

        else if (Math.abs(canvasY - inputY) < lineHeight/1.5) newHovered = lines.length; 
        hoveredLine = newHovered;
        if (hoveredLine !== lastHovered)currentHoverScale = 0;
        renderer.domElement.style.cursor = (hoveredLine >= 0) ? 'pointer' : 'default';

    } else {
        hoveredLine = -1;
        renderer.domElement.style.cursor = 'default';
    }

    if (hoveredLine !== lastHovered) {
        lastHovered = hoveredLine; 
        renderCanvas();
    }
}
renderer.domElement.addEventListener('mousemove', onMouseMove); 
renderer.domElement.addEventListener('mouseleave', () => { hoveredLine = -1;  renderCanvas(); });

function onLineClick() {
    if (hoveredLine === -1) return;
    playClick();
       if (hoveredLine === lines.length){
        
        isReturn = true;
        executeInput(currentInput.trim());    
        
       }else{

    inputValue = hoveredLine < lines.length ? lines[hoveredLine] : currentInput.trim();

    if (inputValue)  {executeInput(inputValue.toLowerCase()); };
    if (inputValue == "") ;

    }
}

renderer.domElement.addEventListener('click', onLineClick);


// Add click listener
renderer.domElement.addEventListener('click', onLineClick);

renderer.domElement.addEventListener('click', (e) => {
    // get mouse position relative to canvas
   //pivot(200,200);

   knobRot+=15;
    img.style.transform = `rotate(${knobRot}deg)`;
    // check if inside boundary
    

    
});

new ResizeObserver(syncRendererToCRT).observe(crtImg);
window.addEventListener('resize', syncRendererToCRT);
syncRendererToCRT();

// --- Animation loop ---
function animate() {
    requestAnimationFrame(animate);


    updateHoverPlane(); // smoothly extrude hover plane
    
    renderer.render(scene, camera);


}

animate();

// --- Initial render ---
renderCanvas();

window.addEventListener('wheel', (e) => {
    const delta = Math.sign(e.deltaY);

    // Allow scrolling through empty lines by assuming a minimum "virtual" line count
    const totalRows = Math.max(renderedLines.length, visibleLines);
    const maxOffset = totalRows - visibleLines;

    scrollOffset += delta;
    if (scrollOffset < 0) scrollOffset = 0;
    if (scrollOffset > maxOffset) scrollOffset = maxOffset;

    renderCanvas();
    renderHoverCanvas();
    e.preventDefault();
}, { passive: false });








</script>
</body>
</html>
